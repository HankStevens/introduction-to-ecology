---
title: "Community structure"
---

![Mt. Le Conte in Tennessee, U.S.A., sits in what was originally part of the Cherokee Nation, prior to their forced removal in the 1830's as part of the *Trail of Tears*. It is now the heart of the Great Smoky Mountains National Park. The Smokies are part of the Blue Ridge geologic and physiographic province of the Appalachian Mountains, which extend from Georgia northward into southeastern Canada. It's tree communities cover a variety of elevations, aspects, and moisture regimes, which were described in Robert Whittaker opus, Vegetation of the Great Smoky Mountains (1956, *Ecol. Mongraphs* 26:1-80.) ](figs/Mt._LeConte_from_Clingmans_Dome_05-31-20.jpeg){#fig-leconte width=75%}

## Goals
In this chapter, you will, 

* represent multivariate community data with quantitative summaries and graphical displays.
* Describe patterns of diversity, including evenness and richness.

## Preparatory steps

1. General background lectures: Download the PDF slides and watch the [video on community structure and diversity](https://drive.google.com/drive/folders/1nWLoEGuWKIWdul9Uvse5qiB1Hf8MCwUv?usp=sharing){target="_blank"} before proceeding.
1. Data: go to our [class data repository](https://drive.google.com/drive/u/1/folders/1FR2FLiW3xyD4Er52YzVTToPZuXXReGRo){target="_blank"}, and download `WHITTAKER_TABLE_3.csv`. 
   a. Make sure the file remains in the same simple format, "comma separated values" (.csv).
   a. Put `WHITTAKER_TABLE_3.csv` in your working directory, `Rwork`.
   a. Continue to make sure the file remains in the same simple format, "comma separated values" (.csv).
1. Find out what you need for the deliverables.

## Background
We have seen examples of how the size of populations are influenced by the physical environment and interactions with other species which may be prey or enemies or mutualists. In this section, we describe how those populations may change in concert with each other and so constitute **communities**.

## DRAFT 

**Do not use for BIO 209W until the following is shortened and edited.**
---
title: "Community Structure With Data From Whittaker (1956)"
format: pdf
date: 2023-11-26
author: Hank Stevens
---

## Community structure

This is a super short introduction to working with multivariate data in which we have lots of species of a similar type (e.g., plant community, fungal community) at multiple sites or samples. 

Make a note of the new functions or commands we introduce.

### Background

Make sure you have read Primer secs. 14-14.2, and seen Hank's lecture on community structure.

A great reference for all this is: McCune, B. and J. Grace with contribution from D. Urban. 2002. Analysis of Ecological Communities. MJM Software, Gleneden Beach, Oregon. 304 pages.

Dr. Mike Palmer has a great website on ordination, The Ordination Website: https://ordination.okstate.edu/

A good introduction to ordination in `vegan`, written by the first author of the `vegan` package, is available is you Google "Oksanen ordination vegan".

Next load relevant data analysis packages. The new one is `vegan`, for vegetation analysis.
```{r}
#| include: false
library(kableExtra) # for making tables in Rmd and Qmd files
```

```{r}
#| message: false
library(vegan) # multivariate analysis
library(tidyverse) # data wrangling and graphics
```

Let's use the following data (@tbl-whit), which is a small subset of Table 3 from Robert Whittaker's gradient analysis of forests in the Smoky Mountains (Whittaker 1956).

```{r}
#| results: hide
d <- data.frame(
  moisture = 1:12,
  Halesia = c(5,8,4,1,9,13,3,1,1, 0,0,0),
  Pinus = c(0,0,0,0,0,0,0,0,1,4,54,49),
  Quercus = c(0,0,0,0,0,2,1,8,24,10,.1,0),
  Tilia = c(29,11,9,1,14,3, 0,0,0,0,0,0),
  Tsuga = c(20,22,34,62,18,.1,.1,1, 0,0,0,0)
)
d
```


```{r}
#| label: tbl-whit
#| echo: false
#| tbl-cap: Small subset of data from Whittaker (1956) Fig. 4 & Table 3, reflecting a moisture gradient.

kbl(d, booktabs=TRUE)
```

Sometimes simply rearranging a table can help turn it into a graphic. Let's group species by how much moisture they prefer; *Tilia* and *Tsuga* seem to like the wettest sites (@tbl-whit2).
```{r}
#| results: hide
d2 <- d %>% select(moisture, Tilia, Tsuga, Halesia, Quercus, Pinus)

# if the above generates an error message, it may be because
# of 'select()' refers to the wrong R package. If you get an errror, 
# try referring specifically to a particular package with the following code. 
# Uncomment the following and use this instead.
# d <- d %>% dplyr::select(moisture, Tilia, Tsuga, Halesia, Quercus, Pinus)

d2
```


```{r}
#| label: tbl-whit2
#| echo: false
#| tbl-cap: Reorganizing Table 1 to comunicate better.

kbl( round(d2,0) )
```

Now let's create a line graph of abundances along this gradient.

First, rearrange the data into a long format.
```{r}
yl <- d2 %>%
  pivot_longer(cols=Tilia:Pinus, values_to="abundance", names_to="species")
head(yl)
```

Now plot abundances by moisture, where each species get's its own color and line type (@fig-whit1). In addition, we will scale the y-axis by square root, in order to avoid hiding the least common species.
```{r}
#| label: fig-whit1
#| fig-cap: Tree species abundances along a moisture gradient in the Smoky Mountains of North Carolina, USA (Whittker 1956). Y-axis scaled by square root transformation.

ggplot(data=yl, aes(x=moisture, y=abundance, 
               color=species, linetype=species)) + 
  geom_line() +
  scale_y_sqrt() +
  labs(y="Abundance", x="Moisture index")
```

## Dissimilarities between sites

Let's calculate differences among sites, but first we should ask ourselves some questions:

1. Should we treat all sites equally?
1. Would we like to consider all species equally, or let the abundances dictate importance?
1. Should we exclude rare species that might appear in samples by chance alone?
1. Do we have an a priori hypothesis or is this primarily exploratory?

The answer to the first (sites equal?) is often a qualified "yes", especially if there might be artifactual differences among sites. Therefore, we often make sure that the totals among sites are adjusted to be equal. 

The answer to the second (species equal?) is often a qualified "yes", if we are interested in community composition and structure, rather than only the abundant species driving carbon fluxes. Indeed, above we graphed the *square roots* of species abundances to help us see the patterns in the less common species.

The answer to the third (rare species?) is often "yes" because we would like to avoid unnecessary stochastic noise in our data. Some species may be uncommon but also habitat generalists; in these cases, they are not responding to anything we are interested in, but rather just present or absent by chance alone. These species would add noise to our analysis and not inform of us of anything interesting. Many authors report that they "removed taxa that appeared in fewer than X samples", where X is a small number of samples relative to their total. Nonetheless, let us assume that we have already removed such species, and so the answer here is "no", because we already have. 

Last, let's assume that our analyses are exploratory because this is not a designed experiment.

Given these answers, we can proceed.

### Treating sites and species equally

A common data transformation is the "Wisconsin" transformation, which is a double standardization method made popular by botanists at the University of Wisconsin. Here, species (in columns) are first standardized by their own maxima, and then sites (in rows) are standardized by site totals.

```{r}
Y <- d2 %>% select(-moisture)
Yw <- wisconsin(Y)
# totals of each site (rows)
apply(Yw, MARGIN=1, sum)

# resulting maxima of each species (cols) 
apply(Yw, MARGIN=2, max)
```

Note that because we re-weighted the sites after weighting the species, the species got adjusted again.

If we wanted to adjust only the species, we could do the following.
```{r}
# Using a function in vegan
decostand(Y, method="max", MARGIN=2)

# Doing the same thing in base R
apply(Y, 2, function(x) x/max(x)) 
```

Sometimes we want to just scale species a little differently using the logarithm or square root to keep species rank abundances less disturbed, but reduce the importance of the really common species. Square root (or fourth root) is useful, because zeroes are not a problem. We could do this:
```{r}
# Use square roots of our data
Ysr <- apply(Y, 2, function(x) (x^0.5)) 
Ysr
```

Now let's calculate distances or dissimilarities among sites, using Euclidean distances with the raw data.

```{r}
Y.euc.raw <- vegdist(Y, method="euclid")
round(Y.euc.raw,1)
```

We see the lower triangle matrix shows all distances among different species. The upper half is redundant and so we don't bother to show those.

Now we do the same thing, but with the square-root transformed abundances, and we compare the two in a scatterplot (@fig-compareEuc).
```{r}
#| label: fig-compareEuc
#| fig-caption: Euclidean distances among sites depends whether the data were transformed. Distances are positively correlated, but distances among some pairs of sites change their rank-order.
Y.euc.sqrt <- vegdist(Ysr, method="euclid")
plot(Y.euc.raw, Y.euc.sqrt )
```

Now calculate other dissimilarities.
```{r}
Y.bray <- vegdist(Ysr, method="bray")
Y.jac <- vegdist(Ysr, method="jaccard")
Y.gow <- vegdist(Ysr, method="gower")
```

And now combine into a data frame.
```{r}
d.dist <- data.frame(
  Y.euc.raw, Y.euc.sqrt, Y.bray, Y.jac, Y.gow
  )
# in the event the above returns an error message, 
# uncomment and use the following:
# d.dist <- data.frame(
#   Y.euc.raw = as.numeric(Y.euc), Y.bray = as.numeric(Y.bray), 
#   Y.jac = as.numeric(Y.jac), Y.gow = as.numeric(Y.gow)
#   )
```

Finally, let's compare these visually using the scatterplots of all dissimilarity measures in a *scatterplot* matrix.
```{r}
pairs(d.dist)
```

We can calculate the Spearman rank-order correlations among these to see how similar they are.
```{r}
cor(d.dist, method="spearman")
```

We see that the Euclidean distances using raw data differ the most from the other dissimilarities. This is not surprising as all the others use square-root transformed data.


## Ordination - a huge topic

Ordination is a dimension reduction technique that attempts to glean emergent simple patterns in multivariate data. Think of it as a 2-D shadow of a 3-D (or 4-D, or 1000-D) object. 

Ordination may be constrained by covariates or unconstrained. We typically constrain an ordination when we have an a priori hypothesis. Here we will will use only one method, and it will be unconstrained.

### Unconstrained ordination
Among the oldest is principal components analysis (PCA). This is a good method when zeroes are very rare in your data, and variables are symmetrically distributed. It can be good for quantitative traits, where all species have some numerical value for each traits. The method is lousy for community data, especially along long gradients.

**Non-metric multidimensional scaling:** Let's use this algorithm, which tries to render fewer dimensions from more. However, we will first do it porrly, by not transforming the data and using a distance measure that is rarely recommended.
```{r}
#| message: false
m1 <- metaMDS(Y, distance="euc",
              autotransform = FALSE,
              k=2, # number of dimensions
              trace=0 # silence simulation progress info
)
m1
plot(m1, type="t")
```


Now we do it better.
```{r}
m2 <- metaMDS(Y, distance="bray",
              autotransform = TRUE,
              k=2, # number of dimensions
              trace=0 # silence simulation progress info
)
m2
plot(m2, type="t")
```






## And now with a larger data set

These data (this data set) is arranged by species in rows, and sites in columns. Usually we do analyses of sites by having sites in rows and species in columns.
```{r}
dw <- read.csv("~/Courses/671/lectures/communities/WHITTAKER_TABLE_3.csv")
dw[is.na(dw)] <- 0
# transpose the data, but exclude the first column of species names

dt <- t(dw[,-1])
# use the species names as column names
colnames(dt) <-  dw$SP
```

Here we don't transform data, and use Euclidean distances.
```{r}
m.whit1 <- metaMDS(dt, distance="euc",
              autotransform = FALSE,
              k=2, # number of dimensions
              trace=0 # silence simulation progress info
)
```
Here we transform data, and use Bray-Curtis distances.
```{r}
m.whit2 <- metaMDS(dt, distance="bray",
              autotransform = TRUE,
              k=2, # number of dimensions
              trace=0 # silence simulation progress info
)
```

Here we plot these both. Can you see differences? 
```{r}
#| fig-show: 'hold'
plot(m.whit1, display="sites", type="t")
plot(m.whit2, display="sites" , type="t")
```